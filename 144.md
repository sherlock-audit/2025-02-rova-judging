Creamy Orchid Weasel

Medium

# User Unable to Re-Participate in Launch Group After Cancellation


## Summary

Users are unable to re-participate in a launch group via the `participate()` function after canceling their participation using the `cancelParticipation()` function.

[Launch.sol#L237](https://github.com/sherlock-audit/2025-02-rova/blob/main/rova-contracts/src/Launch.sol#L237)

## Description

According to the [documentation](https://github.com/dpm-labs/rova-contracts/blob/main/README.md#finalizes-at-participation):

> If users want to cancel their participation compl, they can do so until the launch group ends via the cancelParticipation function. If the participation is cancelled, the user is allowed to participate again in the same launch group via the participate function.

Thus, a user should be able to re-participate in a launch group after canceling. However, this is not the case.

Consider the `cancelParticipation()` function:

```javascript
    function cancelParticipation(CancelParticipationRequest calldata request, bytes calldata signature)
        external
        nonReentrant
        whenNotPaused
        onlyLaunchGroupStatus(request.launchGroupId, LaunchGroupStatus.ACTIVE)
    {

        // Some Validations...

        EnumerableMap.Bytes32ToUintMap storage userTokens = _userTokensByLaunchGroup[request.launchGroupId];
        (, uint256 userTokenAmount) = userTokens.tryGet(request.userId);
        if (userTokenAmount - info.tokenAmount == 0) {

            userTokens.remove(request.userId);

        } else if (userTokenAmount - info.tokenAmount < settings.minTokenAmountPerUser) {

            
            revert MinUserTokenAllocationNotReached(
                request.launchGroupId, request.userId, userTokenAmount, info.tokenAmount
            );

        } else {
            
            userTokens.set(request.userId, userTokenAmount - info.tokenAmount);

        }

        uint256 refundCurrencyAmount = info.currencyAmount;
        IERC20(info.currency).safeTransfer(info.userAddress, refundCurrencyAmount);

        info.tokenAmount = 0;
        info.currencyAmount = 0;

        // the rest...

    }
```

The issue is that the function does not reset `info.userId` upon cancellation. Consequently, when a user attempts to re-participate using the `participate()` function, they trigger the following check:

```javascript
    function participate(ParticipationRequest calldata request, bytes calldata signature)
        external
        nonReentrant
        whenNotPaused
        onlyLaunchGroupStatus(request.launchGroupId, LaunchGroupStatus.ACTIVE)
    {

        // some validations...

@>      if (launchGroupParticipations[request.launchParticipationId].userId != bytes32(0)) {
            revert ParticipationAlreadyExists(request.launchParticipationId);
        }

        // the rest...

    }
```

Additionally, the documentation regarding `launchParticipationId` clarifies: [[1](https://github.com/dpm-labs/rova-contracts/blob/main/README.md#launch-participation), [2](https://github.com/dpm-labs/rova-contracts/blob/main/README.md#request-parameters)]

> When a user participates in a launch group, Rova backend will generate a launch participation identifier that is unique to the user, launch group, and launch. This id will be used to identify the participation in all state-changing functions and across a launch groups' lifecycle.

> launchParticipationId - This is provided to the user and would not come from user input. This is generated by the backend once validations are done and is unique to the user, launch group, and launch.
>
> For cancelParticipation requests, our backend would validate that the launchParticipationId is valid for the launchGroupId and that it the participation belongs to the same user making the cancellation request.

There is no mention of the backend providing a new `launchParticipationId` after cancellation. Since the participation identifier is unique to the user, the check in the `participate()` function will always fail if a user tries to re-participate after cancellation, resulting in a revert.

## Recommended mitigation

A potential mitigation is to clear `info.userId` upon cancellation. However, further analysis is required to ensure that this change does not introduce other issues.