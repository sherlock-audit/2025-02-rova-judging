Shaggy Stone Dove

High

# Message Construction Vulnerability in Move Contract Signature Verification

### **Summary and Impact**
The `rova_sale` contract contains a serious vulnerability in its signature verification mechanism that compromises the entire security model of the protocol. The current implementation allows users to bypass signature validation by exploiting how the message is constructed, potentially leading to unauthorized participation in token sales.

This vulnerability directly violates a core security invariant stated in the documentation: "all user interactions require a signature that is generated by Rova backend signers." The backend signers are meant to "validate the participation request and perform preliminary validation," but this vulnerability undermines that entirely.

Per the documentation, the protocol's security heavily relies on these signatures for "offchain validation on users (e.g. KYC) and ensure only allowed requests go through." With this vulnerability, a user could participate in sales without proper validation, bypassing KYC requirements and other critical checks.

---
### **Vulnerability Details**
The vulnerability exists in how the contract constructs messages for signature verification. Let's examine the problematic code:

https://github.com/sherlock-audit/2025-02-rova/blob/main/rova-movement-contracts/sources/rova_sale.move#L152-L156

The issue stems from concatenating individually BCS-encoded parameters. BCS encoding lacks clear delimiters between values, creating parsing ambiguity. Here's a test demonstrating the vulnerability:

```move
#[test(admin = @rova_sale_addr, framework = @aptos_framework, user = @0x456)]
public entry fun test_signature_bypass(
    admin: &signer, 
    framework: &signer,
    user: &signer
) {
    setup_sale_config(admin, framework);

    let launch_participation_id = b"test_id";
    let token_amount = 100;
    let intended_payment = 1000;
    let actual_payment = 100; // Much lower than intended
    
    let user_addr = signer::address_of(user);
    let malicious_message = vector::empty<u8>();
    
    // Create overlapping encodings
    let crafted_bytes = create_overlapping_bytes(actual_payment);
    vector::append(&mut malicious_message, crafted_bytes);
    vector::append(&mut malicious_message, bcs::to_bytes(&token_amount));
    vector::append(&mut malicious_message, bcs::to_bytes(&launch_participation_id));

    // Generate and verify signature with overlapping message
    let (sk, pk) = ed25519::generate_keys();
    let signature = ed25519::sign_arbitrary_bytes(&sk, malicious_message);
    
    // The contract accepts this signature but processes a different payment amount
    rova_sale::fund(
        user,
        ed25519::signature_to_bytes(&signature),
        ed25519::validated_public_key_to_bytes(&pk),
        launch_participation_id,
        token_amount,
        intended_payment
    );
}
```

This vulnerability allows users to:
1. Participate with incorrect payment amounts
2. Bypass KYC validation
3. Circumvent backend validation checks
4. Create unauthorized launch participations

The documentation states: "For a given payment currency, The total amount of payment currency tokens that can be withdrawn should equal the total amount of payment currency tokens funded for finalized token sale participations." This vulnerability breaks this critical invariant.

---
### **Tools Used**
- Manual Review
- Move

---
### **Recommendations**
Implement a structured approach to message construction:

```move
struct FundMessage has copy, drop {
    user_addr: address,
    payment_amount: u64,
    token_amount: u64,
    launch_participation_id: vector<u8>
}

// In fund function:
let message = FundMessage {
    user_addr: signer::address_of(user),
    payment_amount,
    token_amount,
    launch_participation_id
};
let message_bytes = bcs::to_bytes(&message);
```

This ensures atomic message construction and eliminates parsing ambiguity, maintaining the security properties required by the protocol's design.